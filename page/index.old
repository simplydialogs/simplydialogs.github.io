
<!-- sizing -->
<section id="sizing">
<h2>Sizing</h2>
<p>You can use predefined class names to set dialog default size  </p>
<pre><code class="javascript">Dlg.DEFAULTS.classes = 'small'</code></pre>
<table>
	<tr><td><code>xs</code> / <code>xsmall</code></td><td>18vw / 15vh</td><td><code>xs-width</code> / <code>xs-height</code></td></tr>
	<tr><td><code>sm</code> / <code>small</code></td><td>22vw / 18vh</td><td><code>sm-width</code> / <code>sm-height</code></td></tr>
	<tr><td><code>md</code> / <code>medium</code></td><td>34vw / 31vh</td><td><code>md-width</code> / <code>md-height</code></td></tr>
	<tr><td><code>lg</code> / <code>large</code></td><td>55vw / 52vh</td><td><code>lg-width</code> / <code>lg-height</code></td></tr>
	<tr><td><code>fullsize</code></td><td>100vw / 100vh</td><td><code></code></td></tr>
</table>
<p>You can override the default using options </p>
<pre><code class="javascript">Dlg.info('some text ...', { classes: 'xs' }).then(..)</code></pre>
<p style="margin-bottom:1px;">
	<button id="btn-options-sizing-xs">As above</button>
	<button id="btn-options-sizing-sm">Alert sm</button>
	<button id="btn-options-sizing-md">Error md</button>
	<button id="btn-options-sizing-lg">Confirm lg</button>
	<button id="btn-options-sizing-sm-overflow">Info sm overflow</button>
	<button id="btn-options-sizing-xs-width">Alert xs-width</button>
	<button id="btn-options-sizing-sm-height">Alert sm-height</button>
	<button id="btn-options-sizing-md-width">Alert md-height</button>
	<button id="btn-options-sizing-fullsize">Error fullsize</button>
</p>
<small style="color:gray;">Note: The examples show dimensions, they are not meant to fit</small>
</section>


<!-- positioning -->
<section id="positioning">
<h2>Positioning</h2>
<p>
Per default all dialogs are shown in the center of the viewscreen, but vertically centered between middle and top. 
Both the default centered position <em>and</em> position <code>middle</code> are leaning to the top for aesthetic reasons. 
The default middle is <code>9vh</code> from the top. The <code>left</code>, <code>right</code> margin is <code>4vw</code>;   
<code>top</code>, <code>bottom</code> has <code>5vh</code> margin. 
</p>
<p>You can control the dialog position by using the predefined classes 
<code>top</code>, <code>middle</code>, <code>bottom></code>, <code>left</code>, <code>center</code>, <code>right</code>
in any meaningful combination. Remember: <code>center</code> is vertical, <code>middle</code> is horizontal. </p>
<p>
<button id="btn-positioning-top">top</button>
<button id="btn-positioning-middle">middle</button>
<button id="btn-positioning-bottom">bottom</button><br>
<button id="btn-positioning-left">left</button>
<button id="btn-positioning-center">center</button>
<button id="btn-positioning-right">right</button>
</p>

This snippet show all combinations stacked upon each other :</p>
<pre><code class="javascript">['top left', 'top center', 'top right', 
 'middle left', 'middle center', 'middle right', 
 'bottom left', 'bottom center', 'bottom right'].forEach(function(position) {
  Dlg.info(position, { classes: position })
})
</code></pre>
<p><button id="btn-positioning-all-stacked">Try it out</button></p>
</section>

<!-- keyboard -->
<section id="keyboard">
<h2>Keyboard</h2>
<p>Specify how to react on keyboard by <code>return</code> and <code>escape</code>.
You can set both true or false for all type of dialogs, except <code>wait</code> and <code>progress</code>,
but is mostly useful for the <code>input</code>-dialog. Note: Return / enter are ignored in textareas. 
</p>
<pre><code class="javascript">const options = {
  return: (true | false),
  escape: (true | false),
  input: {
    inputs: [
      { type: 'input', inputType: 'text', label: 'Input', name: 'input', spellcheck: false },
      {	type: 'textarea', label: 'Textarea', name: 'textarea', spellcheck: false }
    ],
    callback: function(state) {
      return state.input.length > 2
    }
  }
}
</code></pre>
<p>This produces a form where you need to enter at least 3 characters to the <code>&lt;input></code> field, and also have an optional <code>&lt;textarea></code>. 
In the first sample you can hit enter and submit the form, in the second you'll need to click on OK (and so on).</p>
<p>
<button id="btn-options-enter-submit-true">return true (default)</button>
<button id="btn-options-enter-submit-false">return false</button>
<button id="btn-options-escape-true">escape true (default)</button>
<button id="btn-options-escape-false">escape false</button>
<button id="btn-options-escape-return-false">Both escape and return false</button>
</p>
</section>

<section id="defaults-buttons-classes">
<h3>buttons.classes</h3>
<p>You can specify default classes for each button, your own layout or adopting the style of a framework. </p>
<pre><code class="javascript">Dlg.DEFAULTS.buttons.classes = {
  ok: 'my btn classes',
  cancel: '',
  yes: '',
  no: ''
}
</code></pre>
</section>


<!-- styling -->
<section id="styling">
<h2>Additional styling</h2>
<p>SimplyDialogs comes with diminutive styling - the very basics like <code>position</code>, <code>max-width</code> and so on - and you are supposed to want to change that styling. There are two ways :</p>
<h4>1. Override defaults</h4>
<p>Simply override the few CSS3 rules found in <code>dialogs.css</code> (must be declared <em>after</em>) :</p>
<pre><code class="css">dialog {
  border-radius: 0;
}
dialog h4 {
  font-size: medium;
}
</code></pre>
<p>etc. That will obvious inflict on all dialogs.</p>
<h4>2. Attach a named CSS class to .classes</h4>
</section>

<!-- wait -->
<section id="progress">
<h2>progress</h2>
<p>The progress dialog cannot be closed or cancelled by the user, but must be closed programmatically by using the <code>close()</code> method.
By default the <code>&lt;progress></code> element is shown in indeterminate state (ongoing with no indication)</p>
<pre><code class="javascript">const progress = Dlg.progress('Lorem ipsum ...')
setTimeout(() => progress.close(), 2000)
</code></pre>
<p>
<button id="btn-progress-indeterminate">indeterminate</button>
<button id="btn-progress-fixed">fixed { value: 75, max: 100 }</button>
</p>
<p>
To make a progressive progress, specify a <code>max</code> value and use <code>setValue</code> to update the progress 
</p>
<pre><code class="javascript">const progress = Dlg.progress('Lorem ipsum ...', { progress: { value: 0, max: 100 }})

//mimick a progressive task
let interval, value = 0
const update = function() {
  value++
  progress.setValue(value)
  progress.setText(`progress ${value}%`)
  if (value > 100) {
    clearInterval(interval)
    progress.close()
  }
}
interval = setInterval(update, 20)
</code></pre>
<p><button id="btn-progress-progress">progress mockup</button></p>
</section>

<!-- wait -->
<section id="wait">
<h2>wait</h2>
<p>When using the <code>wait</code>-dialog, it can be convenient to update the dialog for details about progress or 
whatever there is going on. <code>wait</code> has two special methods for updating the message, <code>setText</code> and <code>addText</code>. 
Both takes a string as argument, that can be plain text or HTML.</p>

<h4>setText</h4>
<p><code>setText</code> replaces the message with new content. Consider this mockup :</p>
<pre><code class="javascript">let counter = 0
let interval = undefined
const wait = Dlg.wait('Lorem ipsum ...')
const replace = function() {
  counter ++
  wait.setText(`text or message changed ${counter} time(s)`)
  if (counter > 5) {
    clearInterval(interval)
    wait.close()
  }
}
interval = setInterval(replace, 1000)
</code></pre>
<p><button id="btn-wait-settext">setText mockup sample</button></p>

<h4>addText</h4>
<p><code>addText</code> appends something to the already existing text/message. The content can be plain text or HTML. Consider this mockup :</p>
<pre><code class="javascript">let counter = 0
let interval = undefined
const wait = Dlg.wait('Lorem ipsum ...')
const append = function() {
  counter ++
  wait.addText(`&lt;br>${counter} line(s) added to message`)
  if (counter > 5) {
    clearInterval(interval)
    wait.close()
  }
}
interval = setInterval(append, 1000)
</code></pre>
<p><button id="btn-wait-addtext">addText mockup sample</button></p>
</section>

<!-- backdrop -->
<section id="defaults-backdrop">
<h2>backdrop</h2>
<p>Across the browsers, their computed default <code>::backdrop</code> CSS more or less look like this :</p>
<pre><code class="css">dialog::backdrop {
  position: fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  background: rgba(0, 0, 0, 0.1);
}
</code></pre>
<p>You can change <code>DEFAULTS.backdrop</code> in order to change the background of the dialogs. You can specify the <code>background</code> style itself by passing a valid CSS class-definition. Here are some examples:</p>
<p><button id="backdrop-none">No backdrop (reset)</button> <button id="backdrop-darker">Darker backdrop</button></p>
<pre><code class="javascript">Dlg.DEFAULTS.backdrop = 'background: rgba(0, 0, 0, 0);'
Dlg.DEFAULTS.backdrop = 'background: rgba(0, 0, 0, 0.5);'
</code></pre>
<p>Or get more inspiration at <a href="https://projects.verou.me/css3patterns/">https://projects.verou.me/css3patterns/</a>, where the ideas below are taken from :</p>
<p><button id="backdrop-carbon">A "carbon" backdrop</button> <button id="backdrop-stairs">A "stair-style" backdrop</button> <button id="backdrop-heart">Because I love You</button></p>
<pre><code class="javascript">Dlg.DEFAULTS.backdrop = `background: linear-gradient(27deg, #151515 5px, transparent 5px) 0 5px,
  linear-gradient(207deg, #151515 5px, transparent 5px) 10px 0px,
  linear-gradient(27deg, #222 5px, transparent 5px) 0px 10px,
  linear-gradient(207deg, #222 5px, transparent 5px) 10px 5px,
  linear-gradient(90deg, #1b1b1b 10px, transparent 10px),
  linear-gradient(#1d1d1d 25%, #1a1a1a 25%, #1a1a1a 50%, transparent 50%, transparent 75%, #242424 75%, #242424);
  background-color: #131313;
  opacity: 0.4;
  background-size: 20px 20px;`

Dlg.DEFAULTS.backdrop = `background: linear-gradient(63deg, #999 23%, transparent 23%) 7px 0,
  linear-gradient(63deg, transparent 74%, #999 78%),
  linear-gradient(63deg, transparent 34%, #999 38%, #999 58%, transparent 62%), #444;
  opacity: 0.4;
  background-size: 16px 48px;`
</code></pre>
</section>

<!-- inputs -->
<section id="advanced-inputs">
<h2>Advanced inputs</h2>
<!---
</section>
--->

<section id="input-options">
<h3>Passing options literal</h3>
<p>You can alter the input form either by changing <code>DEFAULTS</code> or by passing an options literal to <code>input(msg, options)</code> (what you should do) : </p>
<pre><code class="javascript">const options = {
  input: { 
    formLayout: '',
    classes: {
      label: '',
      input: ''
    },
    inputs: [ {â€¦}, ... ],
    callback: undefined
  }
}
</code></pre>
<p>Just pass the attributes you need, if not set <code>.DEFAULTS</code> are used. The elements in the form is positioned by a 
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid" title="CSS grid on MDN">CSS grid</a>, via <code>.formLayout</code>
<code>top</code>|<code>left</code> you can specify the label positions. </p>
</section>

<section id="input-inputs">
<h3>Define inputs</h3>
<p><code>inputs</code> is an array of objects defining each input for the form :</p>
<pre><code class="javascript">const options = {
  input: {
    inputs: [
      { type: 'input', inputType: 'text', label: 'Input', name: 'input', placeholder: 'Input required' },
      { type: 'textarea', label: 'Textarea', name: 'textarea', placeholder: 'Additional text', rows: 4 }
    ]
  }
}
Dlg.input('Lorem ipsum dolor sit amet, consectetur adipiscing elit', options)
</code></pre><p><button id="btn-input-textarea">Test input, textarea</button></p>
</section>

<h3 id="input-autofocus">autofocus</h3>
<p>If you set <code class="javascript">autofocus: true</code>, then the input (or textarea, select)
will be focused when the dialog is shown</p>
<p><button id="btn-input-textarea-autofocus">Test input, textarea focused</button></p>

<h3 id="input-spellcheck">spellcheck</h3>
<p>Browser <code>spellcheck</code> is disabled per default and therefore <em>opt-in</em>; 
Use <code class="javascript">spellcheck: true</code> to enable spellcheck
</p>
<p><button id="btn-input-textarea-spellcheck">Test input, textarea spellcheck</button></p>

<h3 id="input-autocomplete">autocomplete</h3>
<p>Built-in browser <code>autocomplete</code> is <em>opt-in</em> as well; 
Use <code class="javascript">autocomplete: 'on'</code> to enable autocomplete (input elements only)
</p>
<p><button id="btn-input-autocomplete-textarea">Test input autocomplete, textarea</button></p>


<section id="input-form-layout">
<h3>.formLayout</h3>
<p><code>formLayout</code> can contain <code>left</code>/<code>top</code> and <code>full-width</code>. The basic layout have huge 
importance of the look of the dialog. Here all the combinations along with the input/textarea example above :</p>
<pre><code class="javascript">const options = {
  input: {
    formLayout: (not set | top | top full-width | left | left full-width | '')
    inputs: [
      ...
    ]
  }
}
</code></pre>
<p>
<button id="btn-input-form-layout-default">Default</button>
<button id="btn-input-form-layout-top">top</button>
<button id="btn-input-form-layout-top-full-width">top full-width</button>
<button id="btn-input-form-layout-left">left</button>
<button id="btn-input-form-layout-left-full-width">left full-width</button>
<button id="btn-input-form-layout-none">none (empty, undefined)</button>
</p>
</section>

<section id="input-input-type">
<h3>.inputType</h3>
<p>For <code>&lt;input></code>'s you specify the type throgh <code>inputType</code>. If the browser support the input type it can be shown. 
Pass special properties by their name, i.e <code>value</code>, <code>min</code>, <code>placeholder</code> :</p>
<pre><code class="javascript">const options = {
  input: {
    inputs: [
      { type: 'input', inputType: 'text', label: 'Text', name: 'input', spellcheck: false },
      { type: 'input', inputType: 'checkbox', label: 'Checkbox', name: 'checkbox', checked: true },
      { type: 'input', inputType: 'color', label: 'Color', name: 'color', value: '#123456' },
      { type: 'input', inputType: 'number', label: 'Number', name: 'number', value: 42 },
      { type: 'input', inputType: 'password', label: 'Password', name: 'password', style: 'color:maroon;' },
      { type: 'input', inputType: 'date', label: 'Date', name: 'date' },
      { type: 'input', inputType: 'file', label: 'File', name: 'file' },
      { type: 'input', inputType: 'url', label: 'Url', name: 'url' },
      { type: 'input', inputType: 'range', label: 'Range', name: 'range', value: 25, max: 100 },
      { type: 'input', inputType: 'hidden', label: '', name: 'hidden', value: 'You can pass extra values to the form via hidden inputs' }
    ]
  }
}
Dlg.input('Lorem ipsum dolor sit amet, consectetur adipiscing elit', options).then(function(input) {
  console.log('result', input)
})
</code></pre>
<p><button id="btn-input-all">Test many types of input</button> </p>
</section>

<section id="input-radio-select">
<h3>Radios and selects</h3>
<p>Radios are "paired" inputs and selects have child options, so those need a extended definition. Notice the use of <code>value</code> :</p>
<pre><code class="javascript">const options = { 
  input: { 
    inputs [
      { type: 'radio', label: 'radio', name: 'radio', value: 'option2',
          options: [
            { label: 'option1', value: 'option1' },
            { label: 'option2', value: 'option2' },
            { label: 'option3', value: 'option3' }
          ]
      },
      { type: 'select', label: 'select', name: 'select', value: 'option3',
          options: [
            { label: 'option1', value: 'option1' },
            { label: 'option2', value: 'option2' },
            { label: 'option3', value: 'option3' }
          ]
      }
    ],
    callback: function(state) {
      return state.radio !== null && state.select !== null
    }
  }
}	
</code></pre>
<p><button id="btn-input-radio-select">Test radios and select</button> <button id="btn-input-radio-select-no-value">Same, without using value</button> </p>
</section>

<section id="input-form-validation">
<h2>Form validation</h2>
<p>
You can choose between 'native' declarative form validation by specifying form controls as <code>required</code>, 
or programmatically by passing a <code>callback</code>, that can be either a function or a promise. 
</p>

<h3>required</h3>
<p>In your options, mark one or more form controls as <code>required</code> and specify their constraints (if needed), 
just as you would have done in HTML markup. SimplyDialogs support the same limits and patterns you can build by using 
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/required" target=_blank>required</a>
and HTML5 properties. Here is a very basic example where the user is prompted to enter a valid email address :</p>
<pre><code class="javascript">const options = {
  header: 'Enter valid email',
  icon: 'ðŸ“§',
  input: {
    inputs: [{ 
      type: 'input', 
      inputType: 'email', 
      name: 'email', 
      spellcheck: false,
      required: true //<-- mark required as true
    }],
  }
}
Dlg.input('', options).then(input => {
  console.log('email', input)
})
</code></pre>
<p><button id="btn-validation-required-email">Try it out</button></p>
<p>The "magic" works, you dont even have to specify some constraints,
because an input of type email always will be invalid if the email address is invalid - thus the submit button is not enabled before
a valid email address is entered. Here is another very basic example where we are asking for a danish-style phone number, 8 digits :
</p>
<pre><code class="javascript">const options = {
  header: 'Phone number',
  icon: null,
  input: {
    inputs: [{ 
      type: 'input', 
      inputType: 'text', 
      name: 'phone', 
      label: '+45',
      required: true,
      pattern: '[0-9]{8}'
    }],
  }
}
Dlg.input('Enter 8 digit number, regional code implied', options).then(input => {
  console.log('phone', input)
})
</code></pre>
<p><button id="btn-validation-required-danish-phone-number">Test phone pattern</button> </p>
<p>
btn-validation-required-danish-phonenumber

Mark any All you need to do is to mark the form control as required 

using declarative inputs, 
You can 
There are two ways to validate form input: <code>input.callback</code> and <code>input.promise</code>. </p>
If (and only if) you specify a callback (or a promise), the submit-button is disabled and the callback will determine when it should be enabled. 
Callbacks are triggered whenever any of the inputs changes state, and the result will be handled as a boolean; i.e if you return <code>true</code> 
the submit-button will be enabled. The callback passes two params : </p>
<pre><code class="javascript">callback: function(state, dialog) {
  return true || false
}
</code></pre>
<ul>
	<li><code>state</code> is an object literal containing <code>{ name: value }</code> for all inputs.</li>
	<li><code>dialog</code> is the dialog's actual <code>HTMLDialogElement</code>, which can be used to manipulate input fields on the form (or anything else).</li>
</ul>
</section>

<section id="input-callback">
<h4>callback</h4>
<p>Example: You are not allowed to submit before you have entered the secret number 47 :</p>
<pre><code class="javascript">const options = {
  headers: { input: 'What is 42 with inflation?' },
  icons: { input: 'ðŸ––' },
  input: {
    inputs: [	
      { type: 'input', inputType: 'password', label: '', name: 'star-trek-number' }
    ],
    callback: function(state) {
      return parseInt(state['star-trek-number']) === 47
    }
  }
}
Dlg.input(null, options).then(input => {
  console.log(input)
})</code></pre>
<p><button id="btn-input-validation-callback">Try callback example</button> </p>
</section>

<section id="input-promise">
<h4>promise</h4>
<p>A promise should be used when you have more complex / time consuming validation schemes. For example, if you need to lookup an
username in your backend, to test if it is already in use. In the below we just mimick a server-side call by using a timeout :</p>
<pre><code class="javascript">const options = {
  headers: { input: 'Enter user name' },
  icons: { input: '' },
  input: {
    inputs: [	
      { type: 'input', inputType: 'text', label: '', name: 'username' }
    ],
    promise: function(state) {
      return new Promise(function(resolve) {
        if (state.username.length &lt; 5) return resolve(false)
        const letters = /^[0-9a-zA-Z]+$/
        if (!letters.test(state.username)) return resolve(false)
        setTimeout(function() {
          resolve(true)
        }, 1000)
      })
    }
  }
}
Dlg.input('Must be at least 5 characters long and may only contain letters and numbers', options).then(input => {
  console.log(input)
})</code></pre>
<p><button id="btn-input-validation-promise">Try promise example</button> </p>
</section>

<section id="input-login-dialog">
<h3>Login Dialog</h3>
<p>Here is an example of how to show a modal login-dialog. Notice the use of <code>autocomplete: off</code> which turns off annoying auto suggestions : </p>
<pre><code class="javascript">const options = {
  headers: { input: 'Login' },
  icons: { input: 'ðŸ”‘' },
  input: {
    inputs: [	
      { type: 'input', inputType: 'text', label: 'Username', name: 'username', autocomplete: 'off' },
      { type: 'input', inputType: 'password', label: 'Password', name: 'password' }  
    ],
    callback: function(state) {
      return state.username.length > 0 && state.password.length > 0
    }
  }
}
Dlg.input('', options).then(input => {
  console.log('login', input)
  // { username: '...', password: '...' }
})
</code></pre>
<p><button id="btn-input-login-dialog">Test login dialog</button> </p>
</section>

<section id="input-file">
<h3>File input with preview</h3>
<p>You kan combine a <code>image</code> type input with a <code>file</code> type input, and by that create an
image-upload-dialog with preview. It takes a little more options-tweaks than the prior examples: </p>
<pre><code class="javascript">const options = {
  headers: { input: 'Upload Image' },
  icons: { input: 'ðŸ–¼' },
  input: {
    inputs: [
      { type: 'input', 
        inputType: 'image', 
        label: 'Preview', 
        name: 'preview', 
        alt: 'No image yet', 
        disabled: 'disabled',
        src: 'data:image/svg+xml,&lt;svg xmlns="http://www.w3.org/2000/svg"/>',
        style: 'min-height: 30vh; max-height: 50vh; border: 1px solid #dadada; object-fit: contain;' 
      }, { 
        type: 'input', 
        inputType: 'file', 
        label: 'Image', 
        name: 'file', 
        accept: 'image/png, image/gif, image/jpeg' 
      }
    ],
    callback: function(state, dialog) {
      if (state.file) {
        dialog.querySelector('input[type="image"]').src = URL.createObjectURL(state.file)
        return true
      }
    }
  }
}
Dlg.input('Select image file &lt;br>&lt;sup>(PNG, GIF, JPG supported)&lt;/sup>', options).then(function(input) {
  console.log('image upload', input)
})
</code></pre>
<p><button id="btn-input-file">Test image upload</button> </p>
</section>
</section> <!-- advanced-input -->



